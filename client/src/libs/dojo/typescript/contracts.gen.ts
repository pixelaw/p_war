// Generated by dojo-bindgen on Sat, 21 Sep 2024 04:55:57 +0000. Do not modify this file manually.
// Import the necessary types from the recs SDK
// generate again with `sozo build --typescript`
import { Account } from "starknet";
import { DojoProvider } from "@dojoengine/core";
import * as models from "./models.gen";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
  // System definitions for `pixelaw-actions` contract
  function actions() {
    const contract_name = "actions";

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `init` system with the specified Account and calldata
    const init = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "init",
            calldata: [],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing init:", error);
        throw error;
      }
    };

    // Call the `update_permission` system with the specified Account and calldata
    const update_permission = async (props: { account: Account; app_key: bigint; permission: models.Permission }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "update_permission",
            calldata: [
              props.app_key,
              props.permission.app,
              props.permission.color,
              props.permission.owner,
              props.permission.text,
              props.permission.timestamp,
              props.permission.action,
            ],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing update_permission:", error);
        throw error;
      }
    };

    // Call the `has_write_access` system with the specified Account and calldata
    const has_write_access = async (props: {
      account: Account;
      for_player: bigint;
      for_system: bigint;
      pixel: models.Pixel;
      pixel_update: models.PixelUpdate;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "has_write_access",
            calldata: [
              props.for_player,
              props.for_system,
              props.pixel.x,
              props.pixel.y,
              props.pixel.app,
              props.pixel.color,
              props.pixel.created_at,
              props.pixel.updated_at,
              props.pixel.timestamp,
              props.pixel.owner,
              props.pixel.text,
              props.pixel.action,
              props.pixel_update,
            ],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing has_write_access:", error);
        throw error;
      }
    };

    // Call the `process_queue` system with the specified Account and calldata
    const process_queue = async (props: {
      account: Account;
      id: bigint;
      timestamp: number;
      called_system: bigint;
      selector: bigint;
      calldata: bigint[];
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "process_queue",
            calldata: [props.id, props.timestamp, props.called_system, props.selector, ...props.calldata],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing process_queue:", error);
        throw error;
      }
    };

    // Call the `schedule_queue` system with the specified Account and calldata
    const schedule_queue = async (props: {
      account: Account;
      timestamp: number;
      called_system: bigint;
      selector: bigint;
      calldata: bigint[];
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "schedule_queue",
            calldata: [props.timestamp, props.called_system, props.selector, ...props.calldata],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing schedule_queue:", error);
        throw error;
      }
    };

    // Call the `update_pixel` system with the specified Account and calldata
    const update_pixel = async (props: {
      account: Account;
      for_player: bigint;
      for_system: bigint;
      pixel_update: models.PixelUpdate;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "update_pixel",
            calldata: [props.for_player, props.for_system, props.pixel_update],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing update_pixel:", error);
        throw error;
      }
    };

    // Call the `new_app` system with the specified Account and calldata
    const new_app = async (props: { account: Account; system: bigint; name: bigint; icon: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "new_app",
            calldata: [props.system, props.name, props.icon],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing new_app:", error);
        throw error;
      }
    };

    // Call the `get_system_address` system with the specified Account and calldata
    const get_system_address = async (props: { account: Account; for_system: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "get_system_address",
            calldata: [props.for_system],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing get_system_address:", error);
        throw error;
      }
    };

    // Call the `get_player_address` system with the specified Account and calldata
    const get_player_address = async (props: { account: Account; for_player: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "get_player_address",
            calldata: [props.for_player],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing get_player_address:", error);
        throw error;
      }
    };

    // Call the `alert_player` system with the specified Account and calldata
    const alert_player = async (props: {
      account: Account;
      position: models.Position;
      player: bigint;
      message: bigint;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "alert_player",
            calldata: [props.position.x, props.position.y, props.player, props.message],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing alert_player:", error);
        throw error;
      }
    };

    // Call the `set_instruction` system with the specified Account and calldata
    const set_instruction = async (props: { account: Account; selector: bigint; instruction: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "set_instruction",
            calldata: [props.selector, props.instruction],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing set_instruction:", error);
        throw error;
      }
    };

    return {
      world,
      init,
      update_permission,
      has_write_access,
      process_queue,
      schedule_queue,
      update_pixel,
      new_app,
      get_system_address,
      get_player_address,
      alert_player,
      set_instruction,
    };
  }

  // System definitions for `pixelaw-guild_actions` contract
  function guild_actions() {
    const contract_name = "guild_actions";

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `create_guild` system with the specified Account and calldata
    const create_guild = async (props: { account: Account; game_id: number; guild_name: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "create_guild",
            calldata: [props.game_id, props.guild_name],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing create_guild:", error);
        throw error;
      }
    };

    // Call the `add_member` system with the specified Account and calldata
    const add_member = async (props: { account: Account; game_id: number; guild_id: number; new_member: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "add_member",
            calldata: [props.game_id, props.guild_id, props.new_member],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing add_member:", error);
        throw error;
      }
    };

    // Call the `remove_member` system with the specified Account and calldata
    const remove_member = async (props: { account: Account; game_id: number; guild_id: number; member: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "remove_member",
            calldata: [props.game_id, props.guild_id, props.member],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing remove_member:", error);
        throw error;
      }
    };

    // Call the `get_guild_points` system with the specified Account and calldata
    const get_guild_points = async (props: { account: Account; game_id: number; guild_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "get_guild_points",
            calldata: [props.game_id, props.guild_id],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing get_guild_points:", error);
        throw error;
      }
    };

    return {
      world,
      create_guild,
      add_member,
      remove_member,
      get_guild_points,
    };
  }

  // System definitions for `pixelaw-p_war_actions` contract
  function p_war_actions() {
    const contract_name = "p_war_actions";

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `on_pre_update` system with the specified Account and calldata
    const on_pre_update = async (props: {
      account: Account;
      pixel_update: models.PixelUpdate;
      app_caller: models.App;
      player_caller: bigint;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "on_pre_update",
            calldata: [
              props.pixel_update,
              props.app_caller.system,
              props.app_caller.name,
              props.app_caller.icon,
              props.app_caller.action,
              props.player_caller,
            ],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing on_pre_update:", error);
        throw error;
      }
    };

    // Call the `on_post_update` system with the specified Account and calldata
    const on_post_update = async (props: {
      account: Account;
      pixel_update: models.PixelUpdate;
      app_caller: models.App;
      player_caller: bigint;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "on_post_update",
            calldata: [
              props.pixel_update,
              props.app_caller.system,
              props.app_caller.name,
              props.app_caller.icon,
              props.app_caller.action,
              props.player_caller,
            ],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing on_post_update:", error);
        throw error;
      }
    };

    // Call the `set_pixel` system with the specified Account and calldata
    const set_pixel = async (props: { account: Account; default_params: models.DefaultParameters }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "set_pixel",
            calldata: [props.default_params],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing set_pixel:", error);
        throw error;
      }
    };

    // Call the `init` system with the specified Account and calldata
    const init = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "init",
            calldata: [],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing init:", error);
        throw error;
      }
    };

    // Call the `interact` system with the specified Account and calldata
    const interact = async (props: { account: Account; default_params: models.DefaultParameters }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "interact",
            calldata: [props.default_params],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing interact:", error);
        throw error;
      }
    };

    // Call the `create_game` system with the specified Account and calldata
    const create_game = async (props: { account: Account; origin: models.Position }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "create_game",
            calldata: [props.origin.x, props.origin.y],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing create_game:", error);
        throw error;
      }
    };

    // Call the `get_game_id` system with the specified Account and calldata
    const get_game_id = async (props: { account: Account; position: models.Position }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "get_game_id",
            calldata: [props.position.x, props.position.y],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing get_game_id:", error);
        throw error;
      }
    };

    // Call the `place_pixel` system with the specified Account and calldata
    const place_pixel = async (props: { account: Account; app: bigint; default_params: models.DefaultParameters }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "place_pixel",
            calldata: [props.app, props.default_params],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing place_pixel:", error);
        throw error;
      }
    };

    // Call the `update_pixel` system with the specified Account and calldata
    const update_pixel = async (props: { account: Account; pixel_update: models.PixelUpdate }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "update_pixel",
            calldata: [props.pixel_update],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing update_pixel:", error);
        throw error;
      }
    };

    // Call the `end_game` system with the specified Account and calldata
    const end_game = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "end_game",
            calldata: [props.game_id],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing end_game:", error);
        throw error;
      }
    };

    return {
      world,
      on_pre_update,
      on_post_update,
      set_pixel,
      init,
      interact,
      create_game,
      get_game_id,
      place_pixel,
      update_pixel,
      end_game,
    };
  }

  // System definitions for `pixelaw-propose_actions` contract
  function propose_actions() {
    const contract_name = "propose_actions";

    // Call the `create_proposal` system with the specified Account and calldata
    const create_proposal = async (props: {
      account: Account;
      game_id: number;
      proposal_type: number;
      target_args_1: number;
      target_args_2: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "create_proposal",
            calldata: [props.game_id, props.proposal_type, props.target_args_1, props.target_args_2],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing create_proposal:", error);
        throw error;
      }
    };

    // Call the `activate_proposal` system with the specified Account and calldata
    const activate_proposal = async (props: {
      account: Account;
      game_id: number;
      index: number;
      clear_data: models.Position[];
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "activate_proposal",
            calldata: [props.game_id, props.index, ...props.clear_data],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing activate_proposal:", error);
        throw error;
      }
    };

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    return {
      create_proposal,
      activate_proposal,
      world,
    };
  }

  // System definitions for `pixelaw-voting_actions` contract
  function voting_actions() {
    const contract_name = "voting_actions";

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `vote` system with the specified Account and calldata
    const vote = async (props: {
      account: Account;
      game_id: number;
      index: number;
      use_px: number;
      is_in_favor: boolean;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "vote",
            calldata: [props.game_id, props.index, props.use_px, props.is_in_favor],
          },
          "pixelaw"
        );
      } catch (error) {
        console.error("Error executing vote:", error);
        throw error;
      }
    };

    return {
      world,
      vote,
    };
  }

  return {
    actions: actions(),
    guild_actions: guild_actions(),
    p_war_actions: p_war_actions(),
    propose_actions: propose_actions(),
    voting_actions: voting_actions(),
  };
}
